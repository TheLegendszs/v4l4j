package au.edu.jcu.v4l4j.impl.omx;

import java.time.Duration;
import java.util.Stack;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

import au.edu.jcu.v4l4j.api.control.CompositeControl.CompositeControlAccessor;
import au.edu.jcu.v4l4j.api.control.Control;
import au.edu.jcu.v4l4j.impl.jni.NativePointer;
import au.edu.jcu.v4l4j.impl.jni.NativeStruct;

public abstract class AbstractOMXQueryControl<T> implements Control<T> {
	protected final OMXComponent component;
	protected final String name;
	
	protected AbstractOMXQueryControl(OMXComponent component, String name) {
		this.component = component;
		this.name = name;
	}
	
	@Override
	public String getName() {
		return this.name;
	}
	
	@Override
	public void close() {
		// TODO Auto-generated method stub
		
	}
	
	protected abstract <P, R> AbstractOMXQueryControlAccessor<P, T, R> access(AbstractOMXQueryControlAccessor<P, ?, R> parent);
	
	public static abstract class AbstractOMXQueryControlAccessor<P, T, R> implements CompositeControlAccessor<P, T, R> {
		protected final boolean isParentOwner;
		protected final String name;
		protected final AbstractOMXQueryControlAccessor<?, ?, ?> parent;
		protected final Duration timeout;
		protected final Consumer<OMXQueryControlAccessorState> mutator;
		
		protected AbstractOMXQueryControlAccessor(String name, AbstractOMXQueryControlAccessor<?, ?, ?> parent,
				Duration timeout) {
			this(name, parent, timeout, null);
		}
		
		protected AbstractOMXQueryControlAccessor(String name, AbstractOMXQueryControlAccessor<?, ?, ?> parent,
				Duration timeout, Consumer<OMXQueryControlAccessorState> mutator) {
			this(false, name, parent, timeout, mutator);
		}
		
		protected AbstractOMXQueryControlAccessor(boolean isParentOwner, String name,
				AbstractOMXQueryControlAccessor<?, ?, ?> parent, Duration timeout,
				Consumer<OMXQueryControlAccessorState> mutator) {
			this.isParentOwner = isParentOwner;
			this.name = name;
			this.parent = parent;
			this.timeout = timeout;
			this.mutator = mutator;
		}
		
		@Override
		public AbstractOMXQueryControlAccessor<P, T, R> setTimeout(Duration timeout) {
			// We can pass our parent ref to the child because we have the same
			// state
			return chained(timeout, null);
		}
		
		@Override
		@SuppressWarnings("unchecked")
		public AbstractOMXQueryControlAccessor<P, T, R> read(Consumer<T> handler) {
			return this.thenApply(state -> handler.accept((T) state.localPointer.peek().get()));
		}
		
		@Override
		public AbstractOMXQueryControlAccessor<P, T, R> write(T value) {
			return this.write(() -> value);
		}
		
		@Override
		public <E> AbstractOMXQueryControlAccessor<P, T, R> write(String name, E value) {
			return write(name, () -> value);
		}
		
		@Override
		public abstract AbstractOMXQueryControlAccessor<P, T, R> write(Supplier<T> supplier);
		
		@Override
		public abstract <E> AbstractOMXQueryControlAccessor<P, T, R> write(String name, Supplier<E> supplier);
		
		@Override
		public AbstractOMXQueryControlAccessor<P, T, R> update(Function<T, T> mappingFunction) {
			// I'm thinking some kind of copy-mark changed-merge scheme, if I
			// ever get around to it...
			throw new UnsupportedOperationException("This one is hard to implement");
		}
		
		@Override
		@SuppressWarnings("unchecked")
		public <E extends Object> AbstractOMXQueryControlAccessor<P, T, R> update(String name,
				BiFunction<String, E, E> mappingFunction) {
			return thenApply(
					state -> state.basePointer.compute(name, (BiFunction<String, Object, Object>) mappingFunction));
		}
		
		@Override
		public abstract AbstractOMXQueryControlAccessor<P, T, R> set();
		
		@Override
		public AbstractOMXQueryControlAccessor<P, T, R> increase() {
			return this;
		}
		
		@Override
		public AbstractOMXQueryControlAccessor<P, T, R> decrease() {
			return this;
		}
		
		@Override
		public abstract AbstractOMXQueryControlAccessor<P, T, T> setAndGet();
		
		@Override
		@SuppressWarnings("unchecked")
		public P and() {
			// Traverse backwards, finding owner
			AbstractOMXQueryControlAccessor<?, ?, ?> root = this;
			while (!root.isParentOwner) {
				if (root.parent == null)
					throw new IllegalStateException("No owner exists for this accessor");
				root = root.parent;
			}
			AbstractOMXQueryControlAccessor<?, ?, ?> owner = root.parent;
			// Add the call chain of the child methods up to the root
			// to the owner, and return
			return (P) owner.thenApply(this::doCall);
		}
		
		/**
		 * Get the parent reference that should be used for child objects
		 * generated by this object.
		 * 
		 * @return
		 */
		protected AbstractOMXQueryControlAccessor<?, ?, ?> doGetChildParent() {
			if (this.mutator == null)
				return this.parent;
			return this;
		}
		
		/**
		 * Push mutator action onto stack
		 */
		protected <X, Z> AbstractOMXQueryControlAccessor<X, T, Z> thenApply(
				Consumer<OMXQueryControlAccessorState> mutator) {
			return chained(timeout, mutator);
		}
		
		protected <X, Z> AbstractOMXQueryControlAccessor<X, T, Z> chained(Duration timeout,
				Consumer<OMXQueryControlAccessorState> mutator) {
			AbstractOMXQueryControlAccessor<?, ?, ?> parent = doGetChildParent();
			return chained(this.isParentOwner && parent != this, this.name, parent, timeout, mutator);
		}
		
		protected abstract <X, Z> AbstractOMXQueryControlAccessor<X, T, Z> chained(boolean isParentOwner, String name,
				AbstractOMXQueryControlAccessor<?, ?, ?> parent, Duration timeout,
				Consumer<OMXQueryControlAccessorState> mutator);
		
		/**
		 * Method that actually does stuff when invoked.
		 * 
		 * @throws Exception
		 */
		protected void doCall(OMXQueryControlAccessorState state) {
			if (this.parent != null && !this.isParentOwner)
				this.parent.doCall(state);
			else if (this.isParentOwner) {
				// Push state
//				state.localPointer.push(((NativeWrapper<String, ?>) state.localPointer.peek()).getChild(this.name));
			}
			if (this.mutator != null)
				this.mutator.accept(state);
		}
		
		@Override
		@SuppressWarnings("unchecked")
		public R call() throws Exception {
			try (OMXQueryControlAccessorState state = new OMXQueryControlAccessorState()) {
				doCall(state);
				return (R) state.result;
			}
		}
		
	}
	
	protected static class OMXQueryControlAccessorState implements AutoCloseable {
		NativeStruct basePointer;
		Object result = null;
		Stack<NativePointer<?>> localPointer = new Stack<>();
		
		@SuppressWarnings("unchecked")
		public <P extends NativePointer<?>> P localPointer() {
			return (P) localPointer.peek();
		}
		
		public <T, P extends NativePointer<T>> P pushLocal(P pointer) {
			localPointer.push(pointer);
			return pointer;
		}
		
		@SuppressWarnings("unchecked")
		public <T, P extends NativePointer<T>> P popLocal() {
			return (P) localPointer.pop();
		}
		
		public <T> T setResult(T value) {
			this.result = value;
			return value;
		}
		
		@SuppressWarnings("unchecked")
		public <T> T getResult() {
			return (T) this.result;
		}
		
		@Override
		public void close() throws Exception {
			basePointer.close();
		}
	}
}
